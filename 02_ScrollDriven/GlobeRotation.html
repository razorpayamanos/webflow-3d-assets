<script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
</script>

<style>
  .cube-scroll-track {
    height: 400vh; 
    position: relative;
    z-index: 10;
  }

  .cube-sticky-container {
    position: -webkit-sticky;
    position: sticky;
    top: 0;
    width: 100%;
    height: 100vh;
    display: flex;
    justify-content: center;
    align-items: center;
    overflow: hidden;
    cursor: grab;
    background-color: transparent; 
  }
  
  .cube-sticky-container:active {
    cursor: grabbing;
  }

  #three-canvas-container {
    width: 100%;
    height: 100%;
    outline: none;
  }
</style>

<div class="cube-scroll-track">
  <div class="cube-sticky-container">
    <div id="three-canvas-container"></div>
  </div>
</div>

<script type="module">
  import * as THREE from 'three';
  import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

  // --- 1. Setup Scene ---
  const container = document.getElementById('three-canvas-container');
  const scene = new THREE.Scene();

  // --- 2. Setup Camera ---
  const camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
  camera.position.z = 3; 
  camera.position.y = 0; 

  // --- 3. Setup Renderer ---
  const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.setSize(container.clientWidth, container.clientHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.outputColorSpace = THREE.SRGBColorSpace; 
  container.appendChild(renderer.domElement);

  // --- 4. Add Lights ---
  // Ambient light ensures the blue isn't too dark
  const ambientLight = new THREE.AmbientLight(0xffffff, 1.0); 
  scene.add(ambientLight);

  // Directional light creates shadows/depth on the globe shape
  const directionalLight = new THREE.DirectionalLight(0xffffff, 2.0);
  directionalLight.position.set(5, 5, 5);
  scene.add(directionalLight);
  
  // Optional: Backlight to make the edges pop
  const backLight = new THREE.DirectionalLight(0xffffff, 1.0);
  backLight.position.set(-5, 5, -5);
  scene.add(backLight);

  // --- 5. Interaction Variables ---
  let model = null;
  let isDragging = false;
  let previousMousePosition = { x: 0, y: 0 };
  let targetRotationY = 0; 
  let mouseX = 0;
  let mouseY = 0;
  const windowHalfX = window.innerWidth / 2;
  const windowHalfY = window.innerHeight / 2;

  // --- 6. Load the GLB Model ---
  const loader = new GLTFLoader();
  const glbUrl = './assets/Globe.glb'; 

  // Create the Blue Material (#305eff)
  const blueMaterial = new THREE.MeshStandardMaterial({
    color: 0x305eff,     // The exact blue you asked for
    roughness: 0.4,      // 0.0 is mirror, 1.0 is matte. 0.4 is semi-glossy.
    metalness: 0.1,      // Slight metallic tint for realism
  });

  loader.load(
    glbUrl,
    function (gltf) {
      model = gltf.scene;
      
      // A. Center the Model
      const box = new THREE.Box3().setFromObject(model);
      const center = box.getCenter(new THREE.Vector3());
      model.position.sub(center); 

      // B. Scale the Model
      const size = box.getSize(new THREE.Vector3());
      const maxDim = Math.max(size.x, size.y, size.z);
      const scale = 2.5 / maxDim; 
      model.scale.set(scale, scale, scale);

      // C. APPLY THE BLUE MATERIAL
      // We traverse every part of the model. If it is a Mesh, we swap its material.
      model.traverse((child) => {
        if (child.isMesh) {
          child.material = blueMaterial;
        }
      });

      scene.add(model);
    },
    undefined,
    function (error) {
      console.error('ERROR: Could not load model at ' + glbUrl);
    }
  );

  // --- 7. Event Listeners ---
  document.addEventListener('mousemove', (event) => {
    mouseX = (event.clientX - windowHalfX) / 1000; 
    mouseY = (event.clientY - windowHalfY) / 1000;

    if (isDragging) {
      const deltaMove = { x: event.offsetX - previousMousePosition.x };
      targetRotationY += deltaMove.x * 0.005;
    }
    previousMousePosition = { x: event.offsetX, y: event.offsetY };
  });


  document.addEventListener('mousedown', () => { isDragging = true; });
  document.addEventListener('mouseup', () => { isDragging = false; });

  // --- 8. Animation Loop ---
  function animate() {
    requestAnimationFrame(animate);

    if (model) {
      model.rotation.y += (targetRotationY - model.rotation.y) * 0.1;
      
      const parallaxX = mouseY * 0.5; 
      model.rotation.x += (parallaxX - model.rotation.x) * 0.05;
      model.rotation.z = -mouseX * 0.2; 
    }

    renderer.render(scene, camera);
  }
  
  animate();

  // --- 9. Handle Resize ---
  window.addEventListener('resize', () => {
    const width = container.clientWidth;
    const height = container.clientHeight;
    camera.aspect = width / height;
    camera.updateProjectionMatrix();
    renderer.setSize(width, height);
  });
</script>
